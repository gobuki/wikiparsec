-- `Data.LanguageNames`: convert between language codes and language names
-- =======================================================================

-- One of the particularly difficult things about dealing with Wiktionary is
-- that information in different languages is often distinguished by the
-- human-readable name of the language, instead of by a language code.

-- This is largely for historical reasons, because many entries were written
-- before the many languages of Wiktionary were organized by a tangle of templates
-- and Lua code, so the problem is worse on Wiktionaries with more history
-- (English and German).

-- An entry defining a French word in English, for example, may be listed
-- as being in "French"; the same entry in German may be listed as being
-- in "Französisch"; and that entry in Japanese may sensibly be listed as
-- being in `{{fr}}`, which shows up as "フランス語" on the page. We want
-- to be able to recognize all of these as the language code `fr`.

-- This is a small part of what the Python module `langcodes` does, reimplemented
-- in Haskell. In fact, it gets most of its information from a file that's
-- generated by a Python script that uses `langcodes`.

{-# LANGUAGE OverloadedStrings, NoImplicitPrelude #-}

module Data.LanguageNames where
import WikiPrelude

-- Most of the language names we need appear in `Data.LanguageNamesData`,
-- the module that the Python script described above generates.

import Data.LanguageNamesData (languageData)

-- Given that information, we define `lookupLanguage`, whose first argument
-- is the language to look up language names in, and whose second argument
-- is the name to look up. We define a number of special cases that don't
-- appear in LanguageNamesData, then delegate the rest to LanguageNamesData.

-- The English and German Wiktionaries use some names that are not quite the name
-- that langcodes expects:

lookupLanguage :: Language -> Text -> Language
lookupLanguage "en" "Rapanui" = "rap"
lookupLanguage "en" "Tok Pisin" = "tpi"
lookupLanguage "en" "Bokmål" = "nb"
lookupLanguage "de" "International" = "mul"

-- The French Wiktionary uses language codes for most purposes, but occasionally
-- there will be a link referring directly to a section of a page by spelling the
-- language name out in French. We need to be able to recognize those.

lookupLanguage "fr" "Français" = "fr"
lookupLanguage "fr" "Anglais" = "en"
lookupLanguage "fr" "Italian" = "it"
lookupLanguage "fr" "Italien" = "it"
lookupLanguage "fr" "Allemand" = "de"
lookupLanguage "fr" "Espagnol" = "es"

-- When defining multilingual conventions, the French Wiktionary uses the template
-- `{{conv}}`, where it would normally use a language code template such as `{{en}}`.
-- We want to consider this to be the same as the language code `mul`, for
-- "Multilingual" or "Multiple languages".

lookupLanguage "fr" "conv" = "mul"

-- In other cases where a language is expected on the French Wiktionary, it will
-- just be defined by its standard language code.

lookupLanguage "fr" code = toLanguage code

-- Any language we haven't named so far gets looked up in the `languageMap` that
-- is derived from LanguageNamesData.

lookupLanguage lang name = findWithDefault "und" (lang, name) languageMap

-- Why doesn't LanguageNamesData define the map itself, as a big literal?  Well,
-- this is tragic, but the Haskell compiler is not good at handling big,
-- structured literals at all. In fact, what I ended up doing to make this not
-- take 10 minutes to compile was to make LanguageNamesData define nothing but an
-- enormous *string* of comma-separated values, which we parse into the
-- `languageMap` at runtime.

-- We read the CSV string by applying `entryTuple` to each line:

languageMap :: Map (Language, Text) Language
languageMap = mapFromList (map entryTuple (lines languageDataText))

-- `entryTuple` needs to give a (Language, Text) key and a (Language) value for
-- each line, which we extract from the three fields of the CSV.

-- We tell this function that its input is a Text, even though it's actually
-- a crappy old String. The `OverloadedStrings` language extension will convert
-- it to a Text automatically so it fits the type signature.

entryTuple :: Text -> ((Language, Text), Language)
entryTuple line =
  let entry = splitSeq "," line
      Just lang = index entry 0
      Just name = index entry 1
      Just code = index entry 2
  in ((toLanguage lang, name), toLanguage code)

languageDataText :: Text
languageDataText = pack languageData

-- 
-- A note on indexing
-- ------------------

-- `index`, used above, is the Classy Prelude's replacement for `!!`, the index
-- operator, which is the worst idea in Haskell. If you index something out of
-- bounds, `!!` crashes the program at runtime, making it a terrible default.

-- `index seq i` returns a `Maybe` value, which is either `Just` the `i`th element
-- of `seq`, or `Nothing` if it was out of bounds.  Of course, we're confident
-- enough that we're indexing in bounds here that we immediately pattern-match it
-- against `Just x`... which would crash the program with an undefined match
-- result if it got `Nothing`.

-- But at least we *chose* to do it this way, and we let the type system know what
-- we're doing.

-- 